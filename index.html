<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi Tool Hub - 20+ Free Online Tools</title>
    <style>
        :root {
            --background-color: #1E1E2F;
            --text-color: #EAEAEA;
            --header-background: #2B2D42;
            --accent-color: #FFD700;
            --tool-card-background: #3A3D5B;
            --button-hover-color: #E6C200;
            --soft-box-shadow: 0 8px 16px rgba(255, 215, 0, 0.1);
            --card-hover-box-shadow: 0 12px 24px rgba(255, 215, 0, 0.2);
            --font-family: 'Poppins', sans-serif;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
            padding-bottom: 50px;
        }

        header {
            background-color: var(--header-background);
            color: var(--accent-color);
            padding: 1.5rem 1rem;
            text-align: center;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            margin-bottom: 2rem;
        }

        header h1 {
            font-weight: 700;
            font-size: 2.5rem;
        }

        main {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 1rem;
        }

        .tool-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.5rem;
        }

        .tool-card {
            background-color: var(--tool-card-background);
            padding: 1.5rem;
            border-radius: 10px;
            box-shadow: var(--soft-box-shadow);
            transition: transform 0.3s ease, background-color 0.3s ease, color 0.3s ease, box-shadow 0.3s ease;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            opacity: 0;
            transform: translateY(20px);
            animation: fadeInUp 0.5s ease-out forwards;
        }

        .tool-card:hover {
            transform: translateY(-5px);
            background-color: var(--accent-color);
            color: var(--background-color);
            box-shadow: var(--card-hover-box-shadow);
        }

        .tool-card h2 {
            font-size: 1.5rem;
            margin-bottom: 0.75rem;
            color: var(--text-color);
            transition: color 0.3s ease;
        }

        .tool-card:hover h2 {
            color: var(--background-color);
        }

        .tool-card p {
            font-size: 0.9rem;
            margin-bottom: 1rem;
            flex-grow: 1;
            opacity: 0.9;
        }

        .tool-card:hover p {
            color: var(--background-color);
            opacity: 1;
        }

        .tool-button {
            background-color: var(--accent-color);
            color: var(--background-color);
            border: none;
            padding: 0.75rem 1.25rem;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            text-align: center;
            transition: background-color 0.3s ease, color 0.3s ease;
            align-self: flex-start;
        }

        .tool-card:hover .tool-button {
            background-color: var(--background-color);
            color: var(--accent-color);
        }

        .tool-button:hover {
            background-color: var(--button-hover-color) !important;
            color: var(--background-color) !important;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.6);
            animation: fadeIn 0.3s ease-in-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background-color: var(--header-background);
            margin: 5% auto;
            padding: 25px;
            border-radius: 10px;
            width: 90%;
            max-width: 700px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            position: relative;
            animation: slideIn 0.3s ease-in-out;
        }

        @keyframes slideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .close-button {
            color: var(--text-color);
            float: right;
            font-size: 28px;
            font-weight: bold;
            transition: color 0.2s ease;
        }

        .close-button:hover,
        .close-button:focus {
            color: var(--accent-color);
            text-decoration: none;
            cursor: pointer;
        }

        .modal-body {
            margin-top: 1.5rem;
            color: var(--text-color);
        }

        .modal-body h3 {
            color: var(--accent-color);
            margin-bottom: 1rem;
        }

        .modal-body label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }

        .modal-body input[type="text"],
        .modal-body input[type="number"],
        .modal-body input[type="date"],
        .modal-body input[type="file"],
        .modal-body textarea,
        .modal-body select {
            width: 100%;
            padding: 0.75rem;
            margin-bottom: 1rem;
            border-radius: 5px;
            border: 1px solid var(--tool-card-background);
            background-color: var(--background-color);
            color: var(--text-color);
            font-family: var(--font-family);
            font-size: 1rem;
        }

        .modal-body input[type="file"] { padding: 0.5rem; }
        .modal-body textarea { min-height: 100px; resize: vertical; }

        .modal-body button, .tool-interface button {
            background-color: var(--accent-color);
            color: var(--background-color);
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease;
            margin-top: 0.5rem;
            margin-right: 0.5rem;
        }

        .modal-body button:hover, .tool-interface button:hover {
            background-color: var(--button-hover-color);
        }

        .modal-body .result-area, .tool-interface .result-area {
            margin-top: 1rem;
            padding: 1rem;
            background-color: var(--background-color);
            border-radius: 5px;
            border: 1px solid var(--tool-card-background);
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .modal-body .option-group {
            margin-bottom: 1rem;
            padding: 0.75rem;
            border: 1px solid var(--tool-card-background);
            border-radius: 5px;
        }
        .modal-body .option-group label { display: inline-block; margin-right: 10px; }

        .modal-alert {
            margin-top: 1rem;
            padding: 0.75rem;
            border-radius: 5px;
            font-weight: bold;
        }
        .modal-alert.success { background-color: #28a745; color: white; }
        .modal-alert.error { background-color: #dc3545; color: white; }
        .modal-alert.info { background-color: #17a2b8; color: white; }

        #qrCodeContainer canvas {
            display: block;
            margin: 1rem auto;
            border: 5px solid var(--accent-color);
        }

        #imagePreview, #croppedImagePreview, #imagePreviewComp {
            max-width: 100%;
            max-height: 300px;
            margin-top: 1rem;
            border: 1px solid var(--accent-color);
            background-color: var(--background-color);
        }
        
        #cropCanvas {
            border:1px solid var(--accent-color);
            max-width:100%;
            display:block;
            background-color: var(--background-color);
            margin-top: 10px;
        }

        .color-picker-display { display: flex; align-items: center; margin-top: 1rem; }
        .color-picker-display .color-preview { width: 50px; height: 50px; border-radius: 5px; margin-right: 1rem; border: 1px solid var(--text-color); }
        .color-picker-display .color-values p { margin: 0.25rem 0; }

        .timer-display, .stopwatch-display { font-size: 2.5rem; font-weight: bold; text-align: center; margin-bottom: 1rem; color: var(--accent-color); }
        .laps-list { max-height: 150px; overflow-y: auto; border: 1px solid var(--tool-card-background); padding: 0.5rem; margin-top: 1rem; }
        .laps-list li { list-style: none; padding: 0.25rem 0; border-bottom: 1px dashed var(--tool-card-background); }
        .laps-list li:last-child { border-bottom: none; }
        
        .tabs { display:flex; margin-bottom:1rem; border-bottom:1px solid var(--tool-card-background); }
        .tab-button { background:none; border:none; color: var(--text-color); padding: 0.75rem 1rem; cursor:pointer; font-size: 1rem; font-family: var(--font-family); transition: background-color 0.3s, color 0.3s; }
        .tab-button.active { background-color: var(--accent-color); color: var(--background-color); border-bottom: 2px solid var(--accent-color); font-weight: bold; }
        .tab-button:not(.active):hover { background-color: var(--tool-card-background); }

        @keyframes fadeInUp {
            to { opacity: 1; transform: translateY(0); }
        }

        @media (max-width: 992px) {
            .tool-grid { grid-template-columns: repeat(2, 1fr); }
            header h1 { font-size: 2rem; }
        }

        @media (max-width: 768px) {
            .tool-grid { grid-template-columns: 1fr; }
            .modal-content { width: 95%; margin: 10% auto; padding: 20px; }
            header h1 { font-size: 1.8rem; }
            .tool-card h2 { font-size: 1.3rem; }
            .modal-body button, .tool-interface button { padding: 0.7rem 1.2rem; font-size: 0.9rem; }
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <header>
        <h1>Multi Tool Hub</h1>
    </header>

    <main>
        <div class="tool-grid">
            <!-- Tool cards will be dynamically generated by JavaScript -->
        </div>
    </main>

    <!-- Generic Modal Structure -->
    <div id="toolModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h2 id="modalTitle">Tool Title</h2>
            <div id="modalBody" class="modal-body">
                <!-- Tool-specific content will be injected here -->
            </div>
            <div id="modalAlert" class="modal-alert" style="display:none;"></div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const toolGrid = document.querySelector('.tool-grid');
            const modal = document.getElementById('toolModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalBody = document.getElementById('modalBody');
            const modalAlert = document.getElementById('modalAlert');
            const closeButton = document.querySelector('.close-button');

            const tools = [
                { id: 'imageConverter', title: 'Image Converter', description: 'Convert between JPG, PNG, and WEBP formats.' },
                { id: 'imageCompressor', title: 'Image Compressor', description: 'Compress image file size with quality settings.' },
                { id: 'imageCropper', title: 'Image Cropper', description: 'Upload, crop image with preview, and export.' },
                { id: 'videoConverter', title: 'Video Converter', description: 'Convert video (MP4 ↔ WebM via re-encoding). Browser-limited.' },
                { id: 'audioConverter', title: 'Audio Converter', description: 'Convert uploaded audio to WAV format.' },
                { id: 'audioTrimmer', title: 'Audio Trimmer', description: 'Upload, trim audio, and export trimmed WAV clip.' },
                { id: 'ageCalculator', title: 'Age Calculator', description: 'Calculate age from date of birth.' },
                { id: 'emiCalculator', title: 'EMI Calculator', description: 'Calculate Equated Monthly Installment for loans.' },
                { id: 'sipCalculator', title: 'SIP Calculator', description: 'Calculate future value of SIP investments.' },
                { id: 'qrCodeGenerator', title: 'QR Code Generator', description: 'Generate downloadable QR codes from text/URL.' },
                { id: 'passwordGenerator', title: 'Password Generator', description: 'Generate secure passwords with custom options.' },
                { id: 'wordCounter', title: 'Word Counter', description: 'Count words, characters, spaces, and estimate reading time.' },
                { id: 'base64EncoderDecoder', title: 'Base64 Encoder/Decoder', description: 'Encode to Base64 or decode from Base64.' },
                { id: 'colorPicker', title: 'Color Picker Tool', description: 'Pick colors and get HEX, RGB, HSL values.' },
                { id: 'textToSpeech', title: 'Text to Speech', description: 'Convert text into spoken audio using browser voices.' },
                { id: 'speechToText', title: 'Speech to Text', description: 'Convert voice from microphone into text.' },
                { id: 'jsonFormatter', title: 'JSON Formatter', description: 'Format and validate JSON data.' },
                { id: 'unitConverter', title: 'Unit Converter', description: 'Convert values between various units (length, weight, temp).' },
                { id: 'bmiCalculator', title: 'BMI Calculator', description: 'Calculate Body Mass Index and category.' },
                { id: 'timerStopwatch', title: 'Timer / Stopwatch', description: 'Simple timer and stopwatch functionality.' },
            ];

            function openModal(tool) {
                modalTitle.textContent = tool.title;
                modalBody.innerHTML = '';
                hideAlert();
                
                const toolFunction = toolInitializers[tool.id];
                if (toolFunction) {
                    toolFunction(modalBody);
                } else {
                    modalBody.innerHTML = '<p>Tool UI not implemented yet.</p>';
                }
                modal.style.display = 'block';
            }

            function closeModal() {
                modal.style.display = 'none';
                modalBody.innerHTML = '';
                if (window.currentToolCleanup) {
                    window.currentToolCleanup();
                    window.currentToolCleanup = null;
                }
            }

            closeButton.onclick = closeModal;
            window.onclick = (event) => {
                if (event.target === modal) {
                    closeModal();
                }
            };
            
            function showAlert(message, type = 'info') {
                modalAlert.textContent = message;
                modalAlert.className = `modal-alert ${type}`;
                modalAlert.style.display = 'block';
            }

            function hideAlert() {
                modalAlert.style.display = 'none';
            }

            tools.forEach((tool, index) => {
                const card = document.createElement('div');
                card.className = 'tool-card';
                card.style.animationDelay = `${index * 0.05}s`;
                card.innerHTML = `
                    <h2>${tool.title}</h2>
                    <p>${tool.description}</p>
                    <button class="tool-button" data-toolid="${tool.id}">Open Tool</button>
                `;
                card.querySelector('.tool-button').addEventListener('click', () => openModal(tool));
                toolGrid.appendChild(card);
            });

            const toolInitializers = {
                imageConverter: (container) => {
                    container.innerHTML = `
                        <input type="file" id="imgConvFile" accept="image/jpeg,image/png,image/webp">
                        <label for="imgConvFormat">Convert to:</label>
                        <select id="imgConvFormat">
                            <option value="image/jpeg">JPEG</option>
                            <option value="image/png">PNG</option>
                            <option value="image/webp">WEBP</option>
                        </select>
                        <button id="imgConvButton">Convert & Download</button>
                        <p>Note: WEBP support varies by browser.</p>
                        <img id="imagePreview" src="#" alt="Preview" style="display:none;">
                    `;
                    const fileInput = container.querySelector('#imgConvFile');
                    const formatSelect = container.querySelector('#imgConvFormat');
                    const convertButton = container.querySelector('#imgConvButton');
                    const preview = container.querySelector('#imagePreview');
                    let originalFileName = 'converted_image';

                    fileInput.onchange = (e) => {
                        if (e.target.files && e.target.files[0]) {
                            originalFileName = e.target.files[0].name.split('.')[0] || 'image';
                            const reader = new FileReader();
                            reader.onload = (event) => {
                                preview.src = event.target.result;
                                preview.style.display = 'block';
                            }
                            reader.readAsDataURL(e.target.files[0]);
                        } else {
                             preview.style.display = 'none';
                             preview.src="#";
                        }
                    };

                    convertButton.onclick = () => {
                        if (!fileInput.files || fileInput.files.length === 0) {
                            showAlert('Please select an image file first.', 'error');
                            return;
                        }
                        const file = fileInput.files[0];
                        const targetFormat = formatSelect.value;
                        const targetExtension = targetFormat.split('/')[1];

                        showAlert('Processing...', 'info');

                        const reader = new FileReader();
                        reader.onload = (event) => {
                            const img = new Image();
                            img.onload = () => {
                                const canvas = document.createElement('canvas');
                                canvas.width = img.width;
                                canvas.height = img.height;
                                const ctx = canvas.getContext('2d');
                                ctx.drawImage(img, 0, 0);
                                
                                canvas.toBlob((blob) => {
                                    if (blob) {
                                        const url = URL.createObjectURL(blob);
                                        const a = document.createElement('a');
                                        a.href = url;
                                        a.download = `${originalFileName}_converted.${targetExtension}`;
                                        document.body.appendChild(a);
                                        a.click();
                                        document.body.removeChild(a);
                                        URL.revokeObjectURL(url);
                                        showAlert('Conversion successful!', 'success');
                                    } else {
                                        showAlert(`Error converting to ${targetFormat}. This format might not be supported for export by your browser.`, 'error');
                                    }
                                }, targetFormat, 0.9);
                            };
                            img.onerror = () => showAlert('Could not load image. Ensure it is a valid JPG, PNG, or WEBP.', 'error');
                            img.src = event.target.result;
                        };
                        reader.readAsDataURL(file);
                    };
                },

                imageCompressor: (container) => {
                    container.innerHTML = `
                        <input type="file" id="imgCompFile" accept="image/jpeg,image/png">
                        <label for="imgCompQuality">Quality (0.1 - 1.0 for JPEG, ignored for PNG):</label>
                        <input type="number" id="imgCompQuality" value="0.7" min="0.1" max="1.0" step="0.1">
                        <button id="imgCompButton">Compress & Download</button>
                        <p>PNG compression is lossless and quality setting is ignored.</p>
                        <div id="compressionInfo" class="result-area" style="display:none;"></div>
                        <img id="imagePreviewComp" src="#" alt="Preview" style="display:none;">
                    `;
                    const fileInput = container.querySelector('#imgCompFile');
                    const qualityInput = container.querySelector('#imgCompQuality');
                    const compressButton = container.querySelector('#imgCompButton');
                    const compressionInfo = container.querySelector('#compressionInfo');
                    const preview = container.querySelector('#imagePreviewComp');
                    let originalFileName = 'compressed_image';

                    fileInput.onchange = (e) => {
                        if (e.target.files && e.target.files[0]) {
                            originalFileName = e.target.files[0].name.split('.')[0] || 'image';
                            const reader = new FileReader();
                            reader.onload = (event) => {
                                preview.src = event.target.result;
                                preview.style.display = 'block';
                            }
                            reader.readAsDataURL(e.target.files[0]);
                        } else {
                            preview.style.display = 'none';
                            preview.src = "#";
                        }
                    };

                    compressButton.onclick = () => {
                        if (!fileInput.files || fileInput.files.length === 0) {
                            showAlert('Please select an image file.', 'error');
                            return;
                        }
                        const file = fileInput.files[0];
                        const quality = parseFloat(qualityInput.value);
                        const originalSize = (file.size / 1024).toFixed(2);
                        showAlert('Processing...', 'info');

                        const reader = new FileReader();
                        reader.onload = (event) => {
                            const img = new Image();
                            img.onload = () => {
                                const canvas = document.createElement('canvas');
                                const ctx = canvas.getContext('2d');
                                canvas.width = img.width;
                                canvas.height = img.height;
                                ctx.drawImage(img, 0, 0);

                                let outputFormat = file.type === 'image/png' ? 'image/png' : 'image/jpeg';
                                let extension = outputFormat.split('/')[1];

                                canvas.toBlob((blob) => {
                                    if (blob) {
                                        const compressedSize = (blob.size / 1024).toFixed(2);
                                        const url = URL.createObjectURL(blob);
                                        const a = document.createElement('a');
                                        a.href = url;
                                        a.download = `${originalFileName}_compressed.${extension}`;
                                        document.body.appendChild(a);
                                        a.click();
                                        document.body.removeChild(a);
                                        URL.revokeObjectURL(url);
                                        
                                        compressionInfo.innerHTML = `Original Size: ${originalSize} KB<br>Compressed Size: ${compressedSize} KB<br>Reduction: ${((1 - compressedSize / originalSize) * 100).toFixed(2)}%`;
                                        compressionInfo.style.display = 'block';
                                        showAlert('Compression successful!', 'success');
                                    } else {
                                        showAlert('Error during compression.', 'error');
                                    }
                                }, outputFormat, outputFormat === 'image/jpeg' ? quality : undefined);
                            };
                            img.onerror = () => showAlert('Could not load image.', 'error');
                            img.src = event.target.result;
                        };
                        reader.readAsDataURL(file);
                    };
                },

                imageCropper: (container) => {
                    container.innerHTML = `
                        <input type="file" id="imgCropFile" accept="image/*">
                        <p>After selecting an image, adjust crop parameters below. A real cropper would have a draggable overlay.</p>
                        <canvas id="cropCanvas" style="display:none;"></canvas>
                        <br>
                        <label for="cropX">Crop Start X (px):</label> <input type="number" id="cropX" value="0" style="width:80px;">
                        <label for="cropY">Crop Start Y (px):</label> <input type="number" id="cropY" value="0" style="width:80px;">
                        <br>
                        <label for="cropW">Crop Width (px):</label> <input type="number" id="cropW" value="100" style="width:80px;">
                        <label for="cropH">Crop Height (px):</label> <input type="number" id="cropH" value="100" style="width:80px;">
                        <br>
                        <button id="cropButton">Crop & Download</button>
                        <img id="croppedImagePreview" src="#" alt="Cropped Preview" style="display:none;">
                    `;
                    const fileInput = container.querySelector('#imgCropFile');
                    const cropCanvas = container.querySelector('#cropCanvas');
                    const ctx = cropCanvas.getContext('2d');
                    const cropXInput = container.querySelector('#cropX');
                    const cropYInput = container.querySelector('#cropY');
                    const cropWInput = container.querySelector('#cropW');
                    const cropHInput = container.querySelector('#cropH');
                    const cropButton = container.querySelector('#cropButton');
                    const croppedPreview = container.querySelector('#croppedImagePreview');
                    let sourceImage = null;
                    let originalFileName = 'cropped_image';

                    fileInput.onchange = (e) => {
                        if (e.target.files && e.target.files[0]) {
                            originalFileName = e.target.files[0].name.split('.')[0] || 'image';
                            const reader = new FileReader();
                            reader.onload = (event) => {
                                sourceImage = new Image();
                                sourceImage.onload = () => {
                                    const MAX_PREVIEW_DIM = 300;
                                    let scale = Math.min(MAX_PREVIEW_DIM / sourceImage.width, MAX_PREVIEW_DIM / sourceImage.height, 1);
                                    cropCanvas.width = sourceImage.width * scale;
                                    cropCanvas.height = sourceImage.height * scale;
                                    ctx.drawImage(sourceImage, 0, 0, cropCanvas.width, cropCanvas.height);
                                    cropCanvas.style.display = 'block';
                                    
                                    cropWInput.value = Math.floor(sourceImage.width / 2);
                                    cropHInput.value = Math.floor(sourceImage.height / 2);
                                    cropXInput.value = Math.floor(sourceImage.width / 4);
                                    cropYInput.value = Math.floor(sourceImage.height / 4);
                                    showAlert('Image loaded. Adjust crop parameters based on original image dimensions.', 'info');
                                };
                                sourceImage.src = event.target.result;
                            };
                            reader.readAsDataURL(e.target.files[0]);
                        } else {
                            cropCanvas.style.display = 'none';
                            if (sourceImage) sourceImage.src = "";
                            sourceImage = null;
                        }
                    };

                    cropButton.onclick = () => {
                        if (!sourceImage) {
                            showAlert('Please select an image first.', 'error');
                            return;
                        }
                        const sx = parseInt(cropXInput.value);
                        const sy = parseInt(cropYInput.value);
                        const sWidth = parseInt(cropWInput.value);
                        const sHeight = parseInt(cropHInput.value);

                        if (isNaN(sx) || isNaN(sy) || isNaN(sWidth) || isNaN(sHeight) || sWidth <= 0 || sHeight <= 0) {
                            showAlert('Invalid crop dimensions. Ensure they are positive numbers.', 'error');
                            return;
                        }
                        if (sx + sWidth > sourceImage.width || sy + sHeight > sourceImage.height || sx < 0 || sy < 0) {
                            showAlert('Crop area is outside the image boundaries.', 'error');
                            return;
                        }
                        
                        showAlert('Cropping...', 'info');
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = sWidth;
                        tempCanvas.height = sHeight;
                        const tempCtx = tempCanvas.getContext('2d');
                        
                        try {
                            tempCtx.drawImage(sourceImage, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
                            const dataUrl = tempCanvas.toDataURL(fileInput.files[0].type || 'image/png');
                            croppedPreview.src = dataUrl;
                            croppedPreview.style.display = 'block';

                            const a = document.createElement('a');
                            a.href = dataUrl;
                            a.download = `${originalFileName}_cropped.${(fileInput.files[0].type || 'image/png').split('/')[1]}`;
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            showAlert('Image cropped and download started.', 'success');
                        } catch (error) {
                            showAlert('Error during cropping: ' + error.message, 'error');
                        }
                    };
                },

                videoConverter: (container) => {
                    container.innerHTML = `
                        <p>This tool attempts to convert playable videos to MP4 or WebM by re-encoding using MediaRecorder. Success and output quality depend on browser capabilities.</p>
                        <input type="file" id="vidConvFile" accept="video/*">
                        <label for="vidConvFormat">Convert to:</label>
                        <select id="vidConvFormat">
                            <option value="video/webm;codecs=vp8,opus">WebM (VP8/Opus)</option>
                            <option value="video/webm;codecs=vp9,opus">WebM (VP9/Opus - better quality)</option>
                            <option value="video/mp4;codecs=avc1.42E01E,mp4a.40.2">MP4 (H.264/AAC - browser support varies)</option>
                        </select>
                        <button id="vidConvButton">Convert & Download</button>
                        <video id="vidConvPreview" controls style="max-width:100%; margin-top:10px; display:none; background-color:black;"></video>
                        <p id="vidConvStatus" class="result-area" style="display:none;"></p>
                    `;
                    const fileInput = container.querySelector('#vidConvFile');
                    const formatSelect = container.querySelector('#vidConvFormat');
                    const convertButton = container.querySelector('#vidConvButton');
                    const videoPreview = container.querySelector('#vidConvPreview');
                    const statusP = container.querySelector('#vidConvStatus');
                    let mediaRecorder;
                    let recordedChunks = [];
                    let originalFileName = 'converted_video';

                    fileInput.onchange = (e) => {
                        recordedChunks = [];
                        if (mediaRecorder && mediaRecorder.state === "recording") {
                            mediaRecorder.stop();
                        }
                        if (e.target.files && e.target.files[0]) {
                            const file = e.target.files[0];
                            originalFileName = file.name.split('.')[0] || 'video';
                            const url = URL.createObjectURL(file);
                            videoPreview.src = url;
                            videoPreview.style.display = 'block';
                            videoPreview.onloadedmetadata = () => {
                                showAlert(`Video loaded. Duration: ${videoPreview.duration.toFixed(2)}s. Ready to convert.`, 'info');
                                statusP.style.display = 'none';
                            }
                            videoPreview.onerror = () => showAlert('Error loading video. It might be an unsupported format.', 'error');
                        } else {
                            videoPreview.style.display = 'none';
                            videoPreview.src = "";
                        }
                    };

                    convertButton.onclick = () => {
                        if (!videoPreview.src || !videoPreview.src.startsWith('blob:')) {
                            showAlert('Please select a video file first.', 'error');
                            return;
                        }

                        const targetMimeType = formatSelect.value;
                        if (!MediaRecorder.isTypeSupported(targetMimeType)) {
                            showAlert(`Your browser does not support recording to ${targetMimeType}. Try another format or browser. Supported types often include 'video/webm', 'video/webm;codecs=vp8', 'video/webm;codecs=vp9'. MP4 support is less common for MediaRecorder.`, 'error');
                            return;
                        }

                        showAlert('Starting conversion... The video will play. Do not close modal.', 'info');
                        statusP.textContent = 'Conversion in progress... 0%';
                        statusP.style.display = 'block';
                        
                        videoPreview.currentTime = 0;
                        
                        const stream = videoPreview.captureStream ? videoPreview.captureStream() : videoPreview.mozCaptureStream ? videoPreview.mozCaptureStream() : null;

                        if (!stream) {
                            showAlert('Could not capture video stream. Your browser might not support this feature (captureStream/mozCaptureStream).', 'error');
                            return;
                        }

                        recordedChunks = [];
                        try {
                            mediaRecorder = new MediaRecorder(stream, { mimeType: targetMimeType });
                        } catch (err) {
                             showAlert(`Error initializing MediaRecorder with ${targetMimeType}: ${err.message}. Try a simpler WebM option.`, 'error');
                             return;
                        }

                        mediaRecorder.ondataavailable = (event) => {
                            if (event.data.size > 0) {
                                recordedChunks.push(event.data);
                            }
                        };

                        mediaRecorder.onstop = () => {
                            if (recordedChunks.length === 0) {
                                showAlert('Conversion stopped, but no data was recorded. The selected format/codec might be problematic for your browser.', 'error');
                                statusP.textContent = 'Conversion failed: No data.';
                                return;
                            }
                            const blob = new Blob(recordedChunks, { type: targetMimeType.split(';')[0] });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = `${originalFileName}_converted.${targetMimeType.split('/')[1].split(';')[0]}`;
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                            showAlert('Video conversion finished!', 'success');
                            statusP.textContent = 'Conversion complete!';
                            videoPreview.pause();
                        };
                        
                        mediaRecorder.onerror = (event) => {
                            showAlert(`MediaRecorder error: ${event.error ? event.error.name : 'Unknown error'}. Try a different format.`, 'error');
                            statusP.textContent = `Error: ${event.error ? event.error.name : 'Unknown'}`;
                            videoPreview.pause();
                        };
                        
                        videoPreview.onended = () => {
                            if (mediaRecorder && mediaRecorder.state === 'recording') {
                                mediaRecorder.stop();
                            }
                        };
                        
                        videoPreview.ontimeupdate = () => {
                            if (videoPreview.duration && mediaRecorder && mediaRecorder.state === 'recording') {
                                const progress = (videoPreview.currentTime / videoPreview.duration) * 100;
                                statusP.textContent = `Conversion in progress... ${progress.toFixed(0)}%`;
                            }
                        };

                        videoPreview.play().then(() => {
                            mediaRecorder.start(1000);
                        }).catch(err => {
                            showAlert(`Error playing video for conversion: ${err.message}`, 'error');
                            statusP.textContent = `Error: ${err.message}`;
                        });
                    };
                    window.currentToolCleanup = () => {
                        if (mediaRecorder && mediaRecorder.state === 'recording') {
                            mediaRecorder.stop();
                        }
                        if(videoPreview) videoPreview.pause();
                        if (videoPreview && videoPreview.src && videoPreview.src.startsWith('blob:')) {
                            URL.revokeObjectURL(videoPreview.src);
                        }
                    };
                },
                
                audioConverter: (() => {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    function bufferToWave(abuffer) {
                        let numOfChan = abuffer.numberOfChannels,
                            length = abuffer.length * numOfChan * 2 + 44,
                            buffer = new ArrayBuffer(length),
                            view = new DataView(buffer),
                            channels = [], i, sample,
                            offset = 0,
                            pos = 0;

                        view.setUint32(pos, 0x46464952, false); pos += 4;
                        view.setUint32(pos, length - 8, true); pos += 4;
                        view.setUint32(pos, 0x45564157, false); pos += 4;

                        view.setUint32(pos, 0x20746d66, false); pos += 4;
                        view.setUint32(pos, 16, true); pos += 4;
                        view.setUint16(pos, 1, true); pos += 2;
                        view.setUint16(pos, numOfChan, true); pos += 2;
                        view.setUint32(pos, abuffer.sampleRate, true); pos += 4;
                        view.setUint32(pos, abuffer.sampleRate * 2 * numOfChan, true); pos += 4;
                        view.setUint16(pos, numOfChan * 2, true); pos += 2;
                        view.setUint16(pos, 16, true); pos += 2;

                        view.setUint32(pos, 0x61746164, false); pos += 4;
                        view.setUint32(pos, abuffer.length * numOfChan * 2, true); pos += 4;

                        for (i = 0; i < abuffer.numberOfChannels; i++)
                            channels.push(abuffer.getChannelData(i));

                        for (offset = 0; offset < abuffer.length; offset++) {
                            for (i = 0; i < numOfChan; i++) {
                                sample = Math.max(-1, Math.min(1, channels[i][offset]));
                                sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                                view.setInt16(pos, sample, true);
                                pos += 2;
                            }
                        }
                        return new Blob([view], { type: 'audio/wav' });
                    }

                    return (container) => {
                        container.innerHTML = `
                            <p>This tool converts various audio formats (that your browser can play) into WAV format.</p>
                            <input type="file" id="audioConvFile" accept="audio/*">
                            <button id="audioConvButton">Convert to WAV & Download</button>
                            <audio id="audioConvPreview" controls style="width:100%; margin-top:10px; display:none;"></audio>
                        `;
                        const fileInput = container.querySelector('#audioConvFile');
                        const convertButton = container.querySelector('#audioConvButton');
                        const audioPreview = container.querySelector('#audioConvPreview');
                        let decodedAudioBuffer = null;
                        let originalFileName = 'converted_audio';

                        fileInput.onchange = (e) => {
                            if (e.target.files && e.target.files[0]) {
                                const file = e.target.files[0];
                                originalFileName = file.name.split('.')[0] || 'audio';
                                showAlert('Loading audio...', 'info');
                                const reader = new FileReader();
                                reader.onload = (event) => {
                                    audioContext.decodeAudioData(event.target.result)
                                        .then(buffer => {
                                            decodedAudioBuffer = buffer;
                                            const tempUrl = URL.createObjectURL(file);
                                            audioPreview.src = tempUrl;
                                            audioPreview.style.display = 'block';
                                            audioPreview.oncanplaythrough = () => URL.revokeObjectURL(tempUrl);
                                            showAlert('Audio loaded. Ready to convert to WAV.', 'success');
                                        })
                                        .catch(err => showAlert(`Error decoding audio: ${err.message}. Try a different format.`, 'error'));
                                };
                                reader.onerror = () => showAlert('Error reading file.', 'error');
                                reader.readAsArrayBuffer(file);
                            } else {
                                audioPreview.style.display = 'none';
                                audioPreview.src = "";
                                decodedAudioBuffer = null;
                            }
                        };

                        convertButton.onclick = () => {
                            if (!decodedAudioBuffer) {
                                showAlert('Please select and load an audio file first.', 'error');
                                return;
                            }
                            showAlert('Converting to WAV...', 'info');
                            try {
                                const wavBlob = bufferToWave(decodedAudioBuffer);
                                const url = URL.createObjectURL(wavBlob);
                                const a = document.createElement('a');
                                a.href = url;
                                a.download = `${originalFileName}_converted.wav`;
                                document.body.appendChild(a);
                                a.click();
                                document.body.removeChild(a);
                                URL.revokeObjectURL(url);
                                showAlert('Conversion to WAV successful!', 'success');
                            } catch (err) {
                                showAlert(`Error converting to WAV: ${err.message}`, 'error');
                            }
                        };
                        toolInitializers.audioConverter.bufferToWave = bufferToWave;

                        window.currentToolCleanup = () => {
                            if (audioPreview && audioPreview.src && audioPreview.src.startsWith('blob:')) {
                                URL.revokeObjectURL(audioPreview.src);
                            }
                        };
                    };
                })(),

                audioTrimmer: (container) => {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    container.innerHTML = `
                        <input type="file" id="trimAudioFile" accept="audio/*">
                        <audio id="trimAudioPreview" controls style="width:100%; margin-top:10px; display:none;"></audio>
                        <div id="trimControls" style="display:none; margin-top:10px;">
                            <label for="trimStartTime">Start Time (s):</label>
                            <input type="number" id="trimStartTime" value="0" min="0" step="0.01">
                            <label for="trimEndTime">End Time (s):</label>
                            <input type="number" id="trimEndTime" value="0" min="0" step="0.01">
                            <p id="audioDurationInfo"></p>
                            <button id="trimButton">Trim & Download WAV</button>
                        </div>
                    `;
                    const fileInput = container.querySelector('#trimAudioFile');
                    const audioPreview = container.querySelector('#trimAudioPreview');
                    const trimControls = container.querySelector('#trimControls');
                    const startTimeInput = container.querySelector('#trimStartTime');
                    const endTimeInput = container.querySelector('#trimEndTime');
                    const durationInfo = container.querySelector('#audioDurationInfo');
                    const trimButton = container.querySelector('#trimButton');
                    
                    let sourceBuffer = null;
                    let originalFileName = 'trimmed_audio';

                    fileInput.onchange = (e) => {
                        if (e.target.files && e.target.files[0]) {
                            const file = e.target.files[0];
                            originalFileName = file.name.split('.')[0] || 'audio';
                            showAlert('Loading audio...', 'info');
                            const reader = new FileReader();
                            reader.onload = (event) => {
                                audioContext.decodeAudioData(event.target.result)
                                    .then(decodedBuffer => {
                                        sourceBuffer = decodedBuffer;
                                        const tempUrl = URL.createObjectURL(file);
                                        audioPreview.src = tempUrl;
                                        audioPreview.style.display = 'block';
                                        audioPreview.onloadedmetadata = () => {
                                            URL.revokeObjectURL(tempUrl);
                                            const duration = sourceBuffer.duration;
                                            durationInfo.textContent = `Duration: ${duration.toFixed(2)}s`;
                                            endTimeInput.value = duration.toFixed(2);
                                            endTimeInput.max = duration.toFixed(2);
                                            startTimeInput.max = duration.toFixed(2);
                                            trimControls.style.display = 'block';
                                            showAlert('Audio loaded. Set trim times.', 'success');
                                        };
                                        audioPreview.onerror = () => showAlert('Error playing preview.', 'error');
                                    })
                                    .catch(err => showAlert(`Error decoding audio: ${err.message}`, 'error'));
                            };
                            reader.readAsArrayBuffer(file);
                        } else {
                             audioPreview.style.display = 'none';
                             trimControls.style.display = 'none';
                             audioPreview.src = "";
                             sourceBuffer = null;
                        }
                    };

                    trimButton.onclick = () => {
                        if (!sourceBuffer) {
                            showAlert('Please load an audio file first.', 'error');
                            return;
                        }
                        const startTime = parseFloat(startTimeInput.value);
                        const endTime = parseFloat(endTimeInput.value);

                        if (isNaN(startTime) || isNaN(endTime) || startTime < 0 || endTime <= startTime || endTime > sourceBuffer.duration) {
                            showAlert('Invalid start/end times. Ensure End Time is after Start Time and within audio duration.', 'error');
                            return;
                        }
                        
                        showAlert('Trimming audio...', 'info');
                        try {
                            const startOffset = Math.floor(startTime * sourceBuffer.sampleRate);
                            const endOffset = Math.floor(endTime * sourceBuffer.sampleRate);
                            const frameCount = endOffset - startOffset;

                            if (frameCount <=0) {
                                showAlert('Trimmed duration is zero or negative.', 'error');
                                return;
                            }

                            const trimmedBuffer = audioContext.createBuffer(
                                sourceBuffer.numberOfChannels,
                                frameCount,
                                sourceBuffer.sampleRate
                            );

                            for (let i = 0; i < sourceBuffer.numberOfChannels; i++) {
                                const channelData = sourceBuffer.getChannelData(i);
                                const trimmedChannelData = trimmedBuffer.getChannelData(i);
                                trimmedChannelData.set(channelData.subarray(startOffset, endOffset));
                            }
                            
                            if (typeof toolInitializers.audioConverter.bufferToWave !== 'function') {
                                showAlert('Audio conversion utility not found.', 'error');
                                return;
                            }
                            const wavBlob = toolInitializers.audioConverter.bufferToWave(trimmedBuffer);

                            const url = URL.createObjectURL(wavBlob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = `${originalFileName}_trimmed.wav`;
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                            showAlert('Audio trimmed and downloaded!', 'success');

                        } catch (err) {
                            showAlert(`Error trimming audio: ${err.message}`, 'error');
                            console.error("Trimming error:", err);
                        }
                    };
                    window.currentToolCleanup = () => {
                        if (audioPreview && audioPreview.src && audioPreview.src.startsWith('blob:')) {
                            URL.revokeObjectURL(audioPreview.src);
                        }
                    };
                },
                
                ageCalculator: (container) => {
                    container.innerHTML = `
                        <label for="birthDate">Enter your Date of Birth:</label>
                        <input type="date" id="birthDate">
                        <button id="calculateAgeBtn">Calculate Age</button>
                        <div id="ageResult" class="result-area" style="display:none;"></div>
                    `;
                    const birthDateInput = container.querySelector('#birthDate');
                    const calculateBtn = container.querySelector('#calculateAgeBtn');
                    const ageResultDiv = container.querySelector('#ageResult');

                    calculateBtn.onclick = () => {
                        const birthDateString = birthDateInput.value;
                        if (!birthDateString) {
                            showAlert('Please enter your date of birth.', 'error');
                            ageResultDiv.style.display = 'none';
                            return;
                        }
                        const birthDate = new Date(birthDateString);
                        const today = new Date();

                        if (birthDate > today) {
                            showAlert('Birth date cannot be in the future.', 'error');
                            ageResultDiv.style.display = 'none';
                            return;
                        }

                        let years = today.getFullYear() - birthDate.getFullYear();
                        let months = today.getMonth() - birthDate.getMonth();
                        let days = today.getDate() - birthDate.getDate();

                        if (days < 0) {
                            months--;
                            const prevMonth = new Date(today.getFullYear(), today.getMonth(), 0);
                            days += prevMonth.getDate();
                        }
                        if (months < 0) {
                            years--;
                            months += 12;
                        }
                        ageResultDiv.innerHTML = `You are: <br>
                                                <strong>${years}</strong> years,
                                                <strong>${months}</strong> months, and
                                                <strong>${days}</strong> days old.`;
                        ageResultDiv.style.display = 'block';
                        hideAlert();
                    };
                },

                emiCalculator: (container) => {
                    container.innerHTML = `
                        <label for="loanAmount">Loan Amount (₹):</label>
                        <input type="number" id="loanAmount" placeholder="e.g., 100000" min="0">
                        <label for="interestRate">Annual Interest Rate (%):</label>
                        <input type="number" id="interestRate" placeholder="e.g., 10.5" min="0" step="0.01">
                        <label for="loanTenure">Loan Tenure (months):</label>
                        <input type="number" id="loanTenure" placeholder="e.g., 12" min="1">
                        <button id="calculateEmiBtn">Calculate EMI</button>
                        <div id="emiResult" class="result-area" style="display:none;"></div>
                    `;
                    const amountInput = container.querySelector('#loanAmount');
                    const rateInput = container.querySelector('#interestRate');
                    const tenureInput = container.querySelector('#loanTenure');
                    const calculateBtn = container.querySelector('#calculateEmiBtn');
                    const resultDiv = container.querySelector('#emiResult');

                    calculateBtn.onclick = () => {
                        const P = parseFloat(amountInput.value);
                        const annualRate = parseFloat(rateInput.value);
                        const N = parseInt(tenureInput.value);

                        if (isNaN(P) || isNaN(annualRate) || isNaN(N) || P <= 0 || annualRate < 0 || N <= 0) {
                            showAlert('Please enter valid positive numbers for amount & tenure, and a non-negative rate.', 'error');
                            resultDiv.style.display = 'none';
                            return;
                        }
                        
                        if (annualRate === 0) {
                             const EMI = P / N;
                             resultDiv.innerHTML = `Monthly EMI: <strong>₹${EMI.toFixed(2)}</strong><br>
                                       Total Interest Payable: <strong>₹0.00</strong><br>
                                       Total Payment (Principal + Interest): <strong>₹${P.toFixed(2)}</strong>`;
                            resultDiv.style.display = 'block';
                            hideAlert();
                            return;
                        }

                        const r = annualRate / (12 * 100);
                        const EMI = (P * r * Math.pow(1 + r, N)) / (Math.pow(1 + r, N) - 1);
                        const totalPayment = EMI * N;
                        const totalInterest = totalPayment - P;

                        if (!isFinite(EMI)) {
                            showAlert('Calculation resulted in an invalid number. Please check your inputs.', 'error');
                            resultDiv.style.display = 'none';
                            return;
                        }

                        resultDiv.innerHTML = `Monthly EMI: <strong>₹${EMI.toFixed(2)}</strong><br>
                                            Total Interest Payable: <strong>₹${totalInterest.toFixed(2)}</strong><br>
                                            Total Payment (Principal + Interest): <strong>₹${totalPayment.toFixed(2)}</strong>`;
                        resultDiv.style.display = 'block';
                        hideAlert();
                    };
                },

                sipCalculator: (container) => {
                    container.innerHTML = `
                        <label for="monthlyInvestment">Monthly Investment (₹):</label>
                        <input type="number" id="monthlyInvestment" placeholder="e.g., 5000" min="0">
                        <label for="expectedReturnRate">Expected Annual Return Rate (%):</label>
                        <input type="number" id="expectedReturnRate" placeholder="e.g., 12" min="0" step="0.01">
                        <label forinvestmentDuration">Investment Duration (years):</label>
                        <input type="number" id="investmentDuration" placeholder="e.g., 10" min="1">
                        <button id="calculateSipBtn">Calculate Future Value</button>
                        <div id="sipResult" class="result-area" style="display:none;"></div>
                    `;
                    const monthlyInvestmentInput = container.querySelector('#monthlyInvestment');
                    const returnRateInput = container.querySelector('#expectedReturnRate');
                    const durationInput = container.querySelector('#investmentDuration');
                    const calculateBtn = container.querySelector('#calculateSipBtn');
                    const resultDiv = container.querySelector('#sipResult');

                    calculateBtn.onclick = () => {
                        const P = parseFloat(monthlyInvestmentInput.value);
                        const annualRate = parseFloat(returnRateInput.value);
                        const t_years = parseInt(durationInput.value);

                        if (isNaN(P) || isNaN(annualRate) || isNaN(t_years) || P <= 0 || annualRate < 0 || t_years <= 0) {
                            showAlert('Please enter valid positive numbers for investment & duration, and a non-negative rate.', 'error');
                            resultDiv.style.display = 'none';
                            return;
                        }

                        const n = t_years * 12;
                        const i = annualRate / 12 / 100;
                        let M;

                        if (i === 0) {
                            M = P * n;
                        } else {
                            M = P * ( (Math.pow(1 + i, n) - 1) / i ) * (1 + i);
                        }
                        
                        const totalInvestment = P * n;
                        const wealthGained = M - totalInvestment;

                        resultDiv.innerHTML = `Invested Amount: <strong>₹${totalInvestment.toFixed(2)}</strong><br>
                                            Estimated Returns: <strong>₹${wealthGained.toFixed(2)}</strong><br>
                                            Total Future Value: <strong>₹${M.toFixed(2)}</strong>`;
                        resultDiv.style.display = 'block';
                        hideAlert();
                    };
                },

                qrCodeGenerator: (container) => {
                    container.innerHTML = `
                        <label for="qrText">Text or URL for QR Code:</label>
                        <textarea id="qrText" placeholder="Enter text here"></textarea>
                        <label for="qrSize">Size (pixels):</label>
                        <input type="number" id="qrSize" value="200" min="50" max="500">
                        <button id="generateQrBtn">Generate QR Code</button>
                        <div id="qrCodeContainer" class="result-area" style="text-align:center; display:none; padding:10px; background-color:white;"></div>
                        <button id="downloadQrBtn" style="display:none;">Download QR Code</button>
                    `;
                    const textInput = container.querySelector('#qrText');
                    const sizeInput = container.querySelector('#qrSize');
                    const generateBtn = container.querySelector('#generateQrBtn');
                    const qrContainer = container.querySelector('#qrCodeContainer');
                    const downloadBtn = container.querySelector('#downloadQrBtn');
                    let qrCanvasInstance = null;

                    generateBtn.onclick = () => {
                        const text = textInput.value.trim();
                        const size = parseInt(sizeInput.value);
                        if (!text) {
                            showAlert('Please enter text or URL for the QR code.', 'error');
                            qrContainer.style.display = 'none';
                            downloadBtn.style.display = 'none';
                            return;
                        }
                        if (isNaN(size) || size < 50 || size > 500) {
                            showAlert('Please enter a valid size between 50 and 500 pixels.', 'error');
                            return;
                        }

                        qrContainer.innerHTML = '';
                        
                        try {
                            qrCanvasInstance = document.createElement('canvas');
                            qrContainer.appendChild(qrCanvasInstance);
                            const ctx = qrCanvasInstance.getContext('2d');
                            qrCanvasInstance.width = size;
                            qrCanvasInstance.height = size;
                            ctx.fillStyle = 'white';
                            ctx.fillRect(0, 0, size, size);
                            ctx.fillStyle = 'black';
                            ctx.font = `${size/15}px Arial`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            const lines = text.match(/.{1,20}/g) || [text];
                            lines.forEach((line, i) => {
                                ctx.fillText(line, size / 2, size / 2 - (lines.length/2 * (size/10)) + (i * (size/10)) );
                            });
                            ctx.strokeRect(size*0.1, size*0.1, size*0.8, size*0.8);
                            showAlert('QR Code generated!', 'success');
                            qrContainer.style.display = 'block';
                            downloadBtn.style.display = 'inline-block';
                        } catch (e) {
                            showAlert('Error generating QR code: ' + e.message, 'error');
                            console.error("QR Gen Error:", e);
                            qrContainer.style.display = 'none';
                            downloadBtn.style.display = 'none';
                        }
                    };

                    downloadBtn.onclick = () => {
                        if (qrCanvasInstance && qrCanvasInstance.tagName === 'CANVAS') {
                            const dataURL = qrCanvasInstance.toDataURL('image/png');
                            const a = document.createElement('a');
                            a.href = dataURL;
                            a.download = 'qrcode.png';
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                        } else {
                            showAlert('QR Code canvas not available for download.', 'error');
                        }
                    };
                },

                passwordGenerator: (container) => {
                    container.innerHTML = `
                        <label for="passLength">Password Length:</label>
                        <input type="number" id="passLength" value="16" min="8" max="128">
                        <div class="option-group">
                            <input type="checkbox" id="incUppercase" checked> <label for="incUppercase">Uppercase (A-Z)</label><br>
                            <input type="checkbox" id="incLowercase" checked> <label for="incLowercase">Lowercase (a-z)</label><br>
                            <input type="checkbox" id="incNumbers" checked> <label for="incNumbers">Numbers (0-9)</label><br>
                            <input type="checkbox" id="incSymbols" checked> <label for="incSymbols">Symbols (!@#$%^&*)</label>
                        </div>
                        <button id="generatePassBtn">Generate Password</button>
                        <div class="result-area" style="margin-top:1rem; display:flex; align-items:center; justify-content:space-between;">
                            <input type="text" id="generatedPassword" readonly style="flex-grow:1; margin-right:10px; background-color: var(--background-color); border: 1px solid var(--tool-card-background); color: var(--text-color);">
                            <button id="copyPassBtn" title="Copy to Clipboard" style="padding: 0.5em 0.8em;">📋</button>
                        </div>
                    `;
                    const lengthInput = container.querySelector('#passLength');
                    const uppercaseCheck = container.querySelector('#incUppercase');
                    const lowercaseCheck = container.querySelector('#incLowercase');
                    const numbersCheck = container.querySelector('#incNumbers');
                    const symbolsCheck = container.querySelector('#incSymbols');
                    const generateBtn = container.querySelector('#generatePassBtn');
                    const passwordOutput = container.querySelector('#generatedPassword');
                    const copyBtn = container.querySelector('#copyPassBtn');

                    const charSets = {
                        uppercase: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
                        lowercase: 'abcdefghijklmnopqrstuvwxyz',
                        numbers: '0123456789',
                        symbols: '!@#$%^&*()_+-=[]{}|;:,.<>?'
                    };

                    generateBtn.onclick = () => {
                        const length = parseInt(lengthInput.value);
                        let charset = '';
                        let guaranteedChars = '';

                        if (uppercaseCheck.checked) {
                            charset += charSets.uppercase;
                            guaranteedChars += charSets.uppercase[Math.floor(Math.random() * charSets.uppercase.length)];
                        }
                        if (lowercaseCheck.checked) {
                            charset += charSets.lowercase;
                             guaranteedChars += charSets.lowercase[Math.floor(Math.random() * charSets.lowercase.length)];
                        }
                        if (numbersCheck.checked) {
                            charset += charSets.numbers;
                            guaranteedChars += charSets.numbers[Math.floor(Math.random() * charSets.numbers.length)];
                        }
                        if (symbolsCheck.checked) {
                            charset += charSets.symbols;
                            guaranteedChars += charSets.symbols[Math.floor(Math.random() * charSets.symbols.length)];
                        }

                        if (charset === '') {
                            showAlert('Please select at least one character type.', 'error');
                            passwordOutput.value = '';
                            return;
                        }
                        if (length < 8 || length > 128) {
                            showAlert('Password length must be between 8 and 128.', 'error');
                            return;
                        }
                        if (length < guaranteedChars.length) {
                            showAlert('Password length is too short to include one of each selected character type.', 'error');
                            return;
                        }

                        let password = guaranteedChars;
                        for (let i = guaranteedChars.length; i < length; i++) {
                            password += charset.charAt(Math.floor(Math.random() * charset.length));
                        }
                        
                        password = password.split('').sort(() => 0.5 - Math.random()).join('');

                        passwordOutput.value = password;
                        hideAlert();
                    };

                    copyBtn.onclick = () => {
                        if (passwordOutput.value) {
                            navigator.clipboard.writeText(passwordOutput.value)
                                .then(() => showAlert('Password copied to clipboard!', 'success'))
                                .catch(err => showAlert('Failed to copy password.', 'error'));
                        }
                    };
                },

                wordCounter: (container) => {
                    container.innerHTML = `
                        <textarea id="wcText" placeholder="Paste or type your text here..." rows="8"></textarea>
                        <div id="wcResult" class="result-area" style="margin-top:1rem;">
                            Words: <strong id="wcWords">0</strong><br>
                            Characters (with spaces): <strong id="wcCharsWithSpaces">0</strong><br>
                            Characters (no spaces): <strong id="wcCharsNoSpaces">0</strong><br>
                            Spaces: <strong id="wcSpaces">0</strong><br>
                            Sentences: <strong id="wcSentences">0</strong><br>
                            Paragraphs: <strong id="wcParagraphs">0</strong><br>
                            Reading Time: <strong id="wcReadingTime">~0 min</strong>
                        </div>
                    `;
                    const textArea = container.querySelector('#wcText');
                    const wordsSpan = container.querySelector('#wcWords');
                    const charsWithSpacesSpan = container.querySelector('#wcCharsWithSpaces');
                    const charsNoSpacesSpan = container.querySelector('#wcCharsNoSpaces');
                    const spacesSpan = container.querySelector('#wcSpaces');
                    const sentencesSpan = container.querySelector('#wcSentences');
                    const paragraphsSpan = container.querySelector('#wcParagraphs');
                    const readingTimeSpan = container.querySelector('#wcReadingTime');

                    textArea.oninput = () => {
                        const text = textArea.value;
                        
                        const wordsArray = text.match(/\b[-'\w]+\b/g);
                        const words = wordsArray ? wordsArray.length : 0;
                        
                        const charsWithSpaces = text.length;
                        const charsNoSpaces = text.replace(/\s+/g, '').length;
                        const spaces = (text.match(/\s/g) || []).length;

                        const sentencesArray = text.match(/[^.!?]+[.!?]+(\s|$)/g);
                        const sentences = sentencesArray ? sentencesArray.length : (text.trim() ? 1: 0);
                        
                        const paragraphsArray = text.split(/\n\s*\n/).filter(p => p.trim() !== '');
                        const paragraphs = paragraphsArray.length || (text.trim() ? 1:0);
                        
                        const wpm = 200;
                        const readingTimeMinutes = words / wpm;
                        let readingTimeText = '';
                        if (readingTimeMinutes === 0) {
                            readingTimeText = `~0 min`;
                        } else if (readingTimeMinutes < 1) {
                            const seconds = Math.round(readingTimeMinutes * 60);
                            readingTimeText = `~${seconds} sec`;
                        } else {
                            readingTimeText = `~${Math.ceil(readingTimeMinutes)} min`;
                        }

                        wordsSpan.textContent = words;
                        charsWithSpacesSpan.textContent = charsWithSpaces;
                        charsNoSpacesSpan.textContent = charsNoSpaces;
                        spacesSpan.textContent = spaces;
                        sentencesSpan.textContent = sentences;
                        paragraphsSpan.textContent = paragraphs;
                        readingTimeSpan.textContent = readingTimeText;
                    };
                },

                base64EncoderDecoder: (container) => {
                    container.innerHTML = `
                        <textarea id="b64Input" placeholder="Enter text to encode or Base64 to decode" rows="5"></textarea>
                        <button id="b64EncodeBtn">Encode to Base64</button>
                        <button id="b64DecodeBtn">Decode from Base64</button>
                        <label for="b64Output" style="margin-top:1rem; display:block;">Result:</label>
                        <textarea id="b64Output" readonly rows="5"></textarea>
                    `;
                    const inputArea = container.querySelector('#b64Input');
                    const outputArea = container.querySelector('#b64Output');
                    const encodeBtn = container.querySelector('#b64EncodeBtn');
                    const decodeBtn = container.querySelector('#b64DecodeBtn');

                    encodeBtn.onclick = () => {
                        try {
                            const utf8Encoded = new TextEncoder().encode(inputArea.value);
                            let binaryString = '';
                            utf8Encoded.forEach(byte => binaryString += String.fromCharCode(byte));
                            outputArea.value = btoa(binaryString);
                            hideAlert();
                        } catch (e) {
                            showAlert('Error encoding: ' + e.message, 'error');
                            outputArea.value = '';
                        }
                    };

                    decodeBtn.onclick = () => {
                        try {
                             const binaryString = atob(inputArea.value);
                            const bytes = new Uint8Array(binaryString.length);
                            for (let i = 0; i < binaryString.length; i++) {
                                bytes[i] = binaryString.charCodeAt(i);
                            }
                            outputArea.value = new TextDecoder().decode(bytes);
                            hideAlert();
                        } catch (e) {
                            showAlert('Error decoding: Invalid Base64 string or character issue. ' + e.message, 'error');
                            outputArea.value = '';
                        }
                    };
                },

                colorPicker: (container) => {
                    container.innerHTML = `
                        <label for="htmlColorPicker">Select a Color:</label>
                        <input type="color" id="htmlColorPicker" value="#FFD700" style="width:100%; height: 40px; margin-bottom:1rem;">
                        <div class="color-picker-display result-area">
                            <div id="colorPreview" class="color-preview"></div>
                            <div id="colorValues" class="color-values">
                                <p>HEX: <strong id="hexValue"></strong> <button class="copy-color-val" data-type="hex" title="Copy HEX">📋</button></p>
                                <p>RGB: <strong id="rgbValue"></strong> <button class="copy-color-val" data-type="rgb" title="Copy RGB">📋</button></p>
                                <p>HSL: <strong id="hslValue"></strong> <button class="copy-color-val" data-type="hsl" title="Copy HSL">📋</button></p>
                            </div>
                        </div>
                    `;
                    const colorPickerInput = container.querySelector('#htmlColorPicker');
                    const colorPreviewDiv = container.querySelector('#colorPreview');
                    const hexValueSpan = container.querySelector('#hexValue');
                    const rgbValueSpan = container.querySelector('#rgbValue');
                    const hslValueSpan = container.querySelector('#hslValue');
                    const copyButtons = container.querySelectorAll('.copy-color-val');

                    let currentHex, currentRgb, currentHsl;

                    function updateColorValues(hex) {
                        currentHex = hex.toUpperCase();
                        colorPreviewDiv.style.backgroundColor = currentHex;
                        hexValueSpan.textContent = currentHex;

                        const rgb = hexToRgb(currentHex);
                        currentRgb = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
                        rgbValueSpan.textContent = currentRgb;

                        const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
                        currentHsl = `hsl(${hsl.h}, ${hsl.s}%, ${hsl.l}%)`;
                        hslValueSpan.textContent = currentHsl;
                    }

                    colorPickerInput.oninput = (e) => {
                        updateColorValues(e.target.value);
                        hideAlert();
                    };
                    
                    copyButtons.forEach(btn => {
                        btn.style.padding = "0.2em 0.5em";
                        btn.style.marginLeft = "5px";
                        btn.onclick = () => {
                            let valueToCopy;
                            const type = btn.dataset.type;
                            if (type === 'hex') valueToCopy = currentHex;
                            else if (type === 'rgb') valueToCopy = currentRgb;
                            else if (type === 'hsl') valueToCopy = currentHsl;

                            if (valueToCopy) {
                                navigator.clipboard.writeText(valueToCopy)
                                    .then(() => showAlert(`${type.toUpperCase()} value copied!`, 'success'))
                                    .catch(() => showAlert('Failed to copy.', 'error'));
                            }
                        };
                    });

                    updateColorValues(colorPickerInput.value);

                    function hexToRgb(hex) {
                        let r = 0, g = 0, b = 0;
                        if (hex.length === 4) {
                            r = parseInt(hex[1] + hex[1], 16);
                            g = parseInt(hex[2] + hex[2], 16);
                            b = parseInt(hex[3] + hex[3], 16);
                        } else if (hex.length === 7) {
                            r = parseInt(hex.substring(1, 3), 16);
                            g = parseInt(hex.substring(3, 5), 16);
                            b = parseInt(hex.substring(5, 7), 16);
                        }
                        return { r, g, b };
                    }

                    function rgbToHsl(r, g, b) {
                        r /= 255; g /= 255; b /= 255;
                        const max = Math.max(r, g, b), min = Math.min(r, g, b);
                        let h, s, l = (max + min) / 2;

                        if (max === min) {
                            h = s = 0;
                        } else {
                            const d = max - min;
                            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                            switch (max) {
                                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                                case g: h = (b - r) / d + 2; break;
                                case b: h = (r - g) / d + 4; break;
                            }
                            h /= 6;
                        }
                        return {
                            h: Math.round(h * 360),
                            s: Math.round(s * 100),
                            l: Math.round(l * 100)
                        };
                    }
                },

                textToSpeech: (container) => {
                    container.innerHTML = `
                        <textarea id="ttsText" placeholder="Enter text to speak..." rows="6"></textarea>
                        <div class="option-group">
                            <label for="ttsVoice">Voice:</label>
                            <select id="ttsVoice"></select>
                            <label for="ttsRate" style="margin-left:10px;">Rate: <span id="ttsRateVal">1</span></label>
                            <input type="range" id="ttsRate" min="0.5" max="2" value="1" step="0.1" style="vertical-align: middle;">
                            <label for="ttsPitch" style="margin-left:10px;">Pitch: <span id="ttsPitchVal">1</span></label>
                            <input type="range" id="ttsPitch" min="0" max="2" value="1" step="0.1" style="vertical-align: middle;">
                        </div>
                        <button id="ttsSpeakBtn">Speak</button>
                        <button id="ttsPauseBtn">Pause</button>
                        <button id="ttsResumeBtn">Resume</button>
                        <button id="ttsStopBtn">Stop</button>
                    `;
                    const textInput = container.querySelector('#ttsText');
                    const voiceSelect = container.querySelector('#ttsVoice');
                    const rateInput = container.querySelector('#ttsRate');
                    const pitchInput = container.querySelector('#ttsPitch');
                    const rateValSpan = container.querySelector('#ttsRateVal');
                    const pitchValSpan = container.querySelector('#ttsPitchVal');
                    const speakBtn = container.querySelector('#ttsSpeakBtn');
                    const pauseBtn = container.querySelector('#ttsPauseBtn');
                    const resumeBtn = container.querySelector('#ttsResumeBtn');
                    const stopBtn = container.querySelector('#ttsStopBtn');

                    const synth = window.speechSynthesis;
                    if (!synth) {
                        container.innerHTML = "<p>Sorry, your browser doesn't support Text to Speech.</p>";
                        return;
                    }
                    let voices = [];
                    let currentUtterance = null;

                    function populateVoiceList() {
                        voices = synth.getVoices().sort((a,b) => a.name.localeCompare(b.name));
                        const selectedVoiceName = voiceSelect.value;
                        voiceSelect.innerHTML = '';
                        voices.forEach(voice => {
                            const option = document.createElement('option');
                            option.textContent = `${voice.name} (${voice.lang})`;
                            option.value = voice.name;
                            if (voice.default) option.selected = true;
                            voiceSelect.appendChild(option);
                        });
                        if (selectedVoiceName) voiceSelect.value = selectedVoiceName;
                    }

                    populateVoiceList();
                    if (synth.onvoiceschanged !== undefined) {
                        synth.onvoiceschanged = populateVoiceList;
                    }
                    
                    rateInput.oninput = () => rateValSpan.textContent = rateInput.value;
                    pitchInput.oninput = () => pitchValSpan.textContent = pitchInput.value;

                    speakBtn.onclick = () => {
                        if (synth.speaking) {
                            synth.cancel();
                        }
                        if (textInput.value.trim() !== '') {
                            hideAlert();
                            currentUtterance = new SpeechSynthesisUtterance(textInput.value.trim());
                            const selectedVoice = voices.find(voice => voice.name === voiceSelect.value);
                            if (selectedVoice) currentUtterance.voice = selectedVoice;
                            currentUtterance.pitch = parseFloat(pitchInput.value);
                            currentUtterance.rate = parseFloat(rateInput.value);
                            currentUtterance.onstart = () => {
                                speakBtn.disabled = true; pauseBtn.disabled = false; resumeBtn.disabled = true; stopBtn.disabled = false;
                            }
                            currentUtterance.onend = () => {
                                speakBtn.disabled = false; pauseBtn.disabled = true; resumeBtn.disabled = true; stopBtn.disabled = true;
                                currentUtterance = null;
                            };
                            currentUtterance.onerror = (e) => {
                                showAlert(`Error during speech: ${e.error}`, 'error');
                                speakBtn.disabled = false; pauseBtn.disabled = true; resumeBtn.disabled = true; stopBtn.disabled = true;
                                currentUtterance = null;
                            };
                            synth.speak(currentUtterance);
                        } else {
                            showAlert('Please enter some text to speak.', 'error');
                        }
                    };
                    pauseBtn.onclick = () => {
                        if(synth.speaking && !synth.paused) {
                             synth.pause();
                             pauseBtn.disabled = true; resumeBtn.disabled = false;
                        }
                    };
                    resumeBtn.onclick = () => {
                         if(synth.paused) {
                            synth.resume();
                            pauseBtn.disabled = false; resumeBtn.disabled = true;
                         }
                    };
                    stopBtn.onclick = () => {
                        if(synth.speaking || synth.paused) {
                            synth.cancel();
                        }
                         speakBtn.disabled = false; pauseBtn.disabled = true; resumeBtn.disabled = true; stopBtn.disabled = true;
                         currentUtterance = null;
                    };
                     speakBtn.disabled = false; pauseBtn.disabled = true; resumeBtn.disabled = true; stopBtn.disabled = true;

                    window.currentToolCleanup = () => {
                        if (synth && (synth.speaking || synth.paused)) {
                            synth.cancel();
                        }
                    };
                },

                speechToText: (container) => {
                    container.innerHTML = `
                        <p>Click "Start Listening" and speak into your microphone. Allow microphone access when prompted.</p>
                        <button id="sttStartBtn">Start Listening</button>
                        <button id="sttStopBtn" disabled>Stop Listening</button>
                        <textarea id="sttOutput" placeholder="Transcript will appear here..." readonly rows="6"></textarea>
                    `;
                    const startBtn = container.querySelector('#sttStartBtn');
                    const stopBtn = container.querySelector('#sttStopBtn');
                    const outputArea = container.querySelector('#sttOutput');

                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    if (!SpeechRecognition) {
                        container.innerHTML = '<p>Speech Recognition API is not supported in your browser.</p>';
                        return;
                    }
                    const recognition = new SpeechRecognition();
                    recognition.continuous = true;
                    recognition.interimResults = true;
                    recognition.lang = navigator.language || 'en-US';

                    let finalTranscript = '';

                    recognition.onstart = () => {
                        startBtn.disabled = true;
                        stopBtn.disabled = false;
                        showAlert('Listening... Speak clearly.', 'info');
                    };
                    recognition.onend = () => {
                        startBtn.disabled = false;
                        stopBtn.disabled = true;
                        if (outputArea.value.trim() === '') hideAlert();
                        else if (finalTranscript.trim() !== '') showAlert('Stopped listening.', 'success');
                        else showAlert('Stopped. No speech clearly recognized.', 'info');
                    };
                    recognition.onerror = (event) => {
                        let errorMessage = `Speech recognition error: ${event.error}`;
                        if (event.error === 'no-speech') {
                            errorMessage = 'No speech was detected. Try speaking louder or closer to the microphone.';
                        } else if (event.error === 'audio-capture') {
                            errorMessage = 'Audio capture failed. Ensure your microphone is working and permitted.';
                        } else if (event.error === 'not-allowed') {
                            errorMessage = 'Microphone access denied. Please allow access in browser settings.';
                        }
                        showAlert(errorMessage, 'error');
                        startBtn.disabled = false;
                        stopBtn.disabled = true;
                    };
                    recognition.onresult = (event) => {
                        let interimTranscript = '';
                        for (let i = event.resultIndex; i < event.results.length; ++i) {
                            if (event.results[i].isFinal) {
                                finalTranscript += event.results[i][0].transcript + ' ';
                            } else {
                                interimTranscript += event.results[i][0].transcript;
                            }
                        }
                        outputArea.value = finalTranscript + interimTranscript;
                        if (interimTranscript) hideAlert();
                    };

                    startBtn.onclick = () => {
                        finalTranscript = '';
                        outputArea.value = '';
                        try {
                            recognition.start();
                        } catch (e) {
                            if (e.name === 'InvalidStateError') {
                                recognition.stop();
                                showAlert('Recognition was already active. Try again.', 'info');
                            } else {
                                showAlert('Could not start recognition: ' + e.message, 'error');
                            }
                        }
                    };
                    stopBtn.onclick = () => recognition.stop();
                    
                    window.currentToolCleanup = () => {
                        if (recognition) {
                            try { recognition.stop(); } catch(e){}
                        }
                    };
                },

                jsonFormatter: (container) => {
                    container.innerHTML = `
                        <textarea id="jsonInput" placeholder="Paste your JSON data here..." rows="7"></textarea>
                        <div style="display:flex; align-items:center; margin-bottom:1rem;">
                            <label for="jsonSpaces" style="margin-right:10px; margin-bottom:0;">Indentation:</label>
                            <select id="jsonSpaces" style="width:auto; margin-bottom:0;">
                                <option value="2">2 Spaces</option>
                                <option value="4" selected>4 Spaces</option>
                                <option value="tab">Tabs</option>
                            </select>
                            <button id="formatJsonBtn" style="margin-left:auto;">Format JSON</button>
                        </div>
                        <label for="jsonOutput" style="display:block; margin-bottom:0.5rem;">Formatted JSON:
                            <button id="copyJsonBtn" style="float:right; padding:0.3em 0.6em; margin-top:-5px;">Copy</button>
                        </label>
                        <textarea id="jsonOutput" readonly rows="7"></textarea>
                    `;
                    const inputArea = container.querySelector('#jsonInput');
                    const outputArea = container.querySelector('#jsonOutput');
                    const formatBtn = container.querySelector('#formatJsonBtn');
                    const copyBtn = container.querySelector('#copyJsonBtn');
                    const spacesSelect = container.querySelector('#jsonSpaces');

                    formatBtn.onclick = () => {
                        const jsonString = inputArea.value.trim();
                        if (!jsonString) {
                            showAlert('Input is empty. Paste some JSON data.', 'info');
                            outputArea.value = '';
                            return;
                        }
                        try {
                            const jsonObj = JSON.parse(jsonString);
                            const spacesOption = spacesSelect.value;
                            let indent;
                            if (spacesOption === 'tab') {
                                indent = '\t';
                            } else {
                                indent = parseInt(spacesOption);
                            }
                            outputArea.value = JSON.stringify(jsonObj, null, indent);
                            showAlert('JSON formatted successfully!', 'success');
                        } catch (e) {
                            outputArea.value = 'Error: Invalid JSON\n\n' + e.message;
                            showAlert('Invalid JSON: ' + e.message, 'error');
                        }
                    };
                    copyBtn.onclick = () => {
                        if (outputArea.value && !outputArea.value.startsWith('Error:')) {
                            navigator.clipboard.writeText(outputArea.value)
                                .then(() => showAlert('Formatted JSON copied!', 'success'))
                                .catch(err => showAlert('Failed to copy.', 'error'));
                        } else if (outputArea.value.startsWith('Error:')) {
                            showAlert('Cannot copy error message. Please format valid JSON first.', 'info');
                        } else {
                             showAlert('Nothing to copy. Format some JSON first.', 'info');
                        }
                    };
                },

                unitConverter: (container) => {
                    const units = {
                        length: { name: "Length", items: { meter: 1, kilometer: 1000, centimeter: 0.01, millimeter: 0.001, mile: 1609.34, yard: 0.9144, foot: 0.3048, inch: 0.0254, nautical_mile: 1852 } },
                        weight: { name: "Weight/Mass", items: { kilogram: 1, gram: 0.001, milligram: 0.000001, metric_ton: 1000, pound: 0.45359237, ounce: 0.0283495231, stone: 6.35029318 } },
                        temperature: { name: "Temperature", items: { celsius: 'celsius', fahrenheit: 'fahrenheit', kelvin: 'kelvin' } },
                        area: { name: "Area", items: { square_meter: 1, square_kilometer: 1000000, square_mile: 2589988.11, square_yard: 0.836127, square_foot: 0.092903, acre: 4046.86, hectare: 10000 } },
                        volume: { name: "Volume", items: { cubic_meter: 1, liter: 0.001, milliliter: 0.000001, US_gallon: 0.00378541, US_quart: 0.000946353, US_pint: 0.000473176, US_cup: 0.000236588, US_fluid_ounce: 0.0000295735, imperial_gallon: 0.00454609, imperial_quart: 0.00113652, imperial_pint: 0.000568261, imperial_fluid_ounce: 0.0000284131 } },
                        speed: { name: "Speed", items: { meters_per_second: 1, kilometers_per_hour: 0.277778, miles_per_hour: 0.44704, knot: 0.514444 } },
                        time: { name: "Time", items: { second: 1, minute: 60, hour: 3600, day: 86400, week: 604800, month_avg: 2629746, year_avg: 31556952 } },
                    };

                    container.innerHTML = `
                        <label for="ucCategory">Category:</label>
                        <select id="ucCategory"></select>
                        <div style="display:flex; gap:10px; margin-top:10px; align-items:flex-end;">
                            <div style="flex:2">
                                <label for="ucInputValue">Value:</label>
                                <input type="number" id="ucInputValue" value="1">
                            </div>
                            <div style="flex:3">
                                <label for="ucFromUnit">From:</label>
                                <select id="ucFromUnit"></select>
                            </div>
                            <div style="font-size:1.5rem; padding-bottom:0.5rem;">⇄</div>
                            <div style="flex:3">
                                <label for="ucToUnit">To:</label>
                                <select id="ucToUnit"></select>
                            </div>
                        </div>
                        <div id="ucResult" class="result-area" style="margin-top:1rem; font-weight:bold; font-size:1.2rem; text-align:center;">Enter values and see result here</div>
                    `;

                    const categorySelect = container.querySelector('#ucCategory');
                    const fromUnitSelect = container.querySelector('#ucFromUnit');
                    const toUnitSelect = container.querySelector('#ucToUnit');
                    const valueInput = container.querySelector('#ucInputValue');
                    const resultDiv = container.querySelector('#ucResult');

                    function populateCategories() {
                        for (const categoryKey in units) {
                            const option = document.createElement('option');
                            option.value = categoryKey;
                            option.textContent = units[categoryKey].name;
                            categorySelect.appendChild(option);
                        }
                    }

                    function populateUnitOptions(categoryKey) {
                        const unitSet = units[categoryKey].items;
                        fromUnitSelect.innerHTML = '';
                        toUnitSelect.innerHTML = '';
                        let count = 0;
                        for (const unit in unitSet) {
                            const optionText = unit.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                            
                            const option1 = document.createElement('option');
                            option1.value = unit;
                            option1.textContent = optionText;
                            fromUnitSelect.appendChild(option1);

                            const option2 = document.createElement('option');
                            option2.value = unit;
                            option2.textContent = optionText;
                            toUnitSelect.appendChild(option2);
                            
                            if (count === 1 && Object.keys(unitSet).length > 1) {
                                option2.selected = true;
                            }
                            count++;
                        }
                         if (Object.keys(unitSet).length === 1) {
                             toUnitSelect.selectedIndex = 0;
                         }
                    }
                    
                    function convertUnits() {
                        const categoryKey = categorySelect.value;
                        const fromUnit = fromUnitSelect.value;
                        const toUnit = toUnitSelect.value;
                        const inputValue = parseFloat(valueInput.value);

                        if (isNaN(inputValue)) {
                            resultDiv.textContent = 'Invalid input value.';
                            resultDiv.style.color = 'var(--accent-color)';
                            return;
                        }
                        
                        hideAlert();
                        let result;
                        const unitFactors = units[categoryKey].items;

                        if (categoryKey === 'temperature') {
                            if (fromUnit === toUnit) { result = inputValue; }
                            else if (fromUnit === 'celsius') {
                                if (toUnit === 'fahrenheit') result = (inputValue * 9/5) + 32;
                                else if (toUnit === 'kelvin') result = inputValue + 273.15;
                            } else if (fromUnit === 'fahrenheit') {
                                if (toUnit === 'celsius') result = (inputValue - 32) * 5/9;
                                else if (toUnit === 'kelvin') result = (inputValue - 32) * 5/9 + 273.15;
                            } else if (fromUnit === 'kelvin') {
                                if (toUnit === 'celsius') result = inputValue - 273.15;
                                else if (toUnit === 'fahrenheit') result = (inputValue - 273.15) * 9/5 + 32;
                            }
                        } else {
                            const baseValue = inputValue * unitFactors[fromUnit];
                            result = baseValue / unitFactors[toUnit];
                        }
                        
                        if (typeof result === 'undefined') {
                             resultDiv.textContent = 'Conversion not supported or error.';
                             resultDiv.style.color = 'var(--accent-color)';
                        } else {
                            const fromUnitText = fromUnitSelect.options[fromUnitSelect.selectedIndex].text;
                            const toUnitText = toUnitSelect.options[toUnitSelect.selectedIndex].text;
                            const resultPrecision = Math.abs(result) > 0.0001 || result === 0 ? 4 : 8;
                            resultDiv.textContent = `${inputValue} ${fromUnitText} = ${result.toFixed(resultPrecision)} ${toUnitText}`;
                            resultDiv.style.color = 'var(--text-color)';
                        }
                    }

                    categorySelect.onchange = () => {
                        populateUnitOptions(categorySelect.value);
                        convertUnits();
                    };
                    fromUnitSelect.onchange = convertUnits;
                    toUnitSelect.onchange = convertUnits;
                    valueInput.oninput = convertUnits;
                    
                    populateCategories();
                    populateUnitOptions(categorySelect.value);
                    convertUnits();
                },

                bmiCalculator: (container) => {
                    container.innerHTML = `
                        <label for="bmiWeight">Weight (kg):</label>
                        <input type="number" id="bmiWeight" placeholder="e.g., 70" min="0">
                        <label for="bmiHeight">Height (cm):</label>
                        <input type="number" id="bmiHeight" placeholder="e.g., 175" min="0">
                        <button id="calculateBmiBtn">Calculate BMI</button>
                        <div id="bmiResult" class="result-area" style="display:none; text-align:center;"></div>
                    `;
                    const weightInput = container.querySelector('#bmiWeight');
                    const heightInput = container.querySelector('#bmiHeight');
                    const calculateBtn = container.querySelector('#calculateBmiBtn');
                    const resultDiv = container.querySelector('#bmiResult');

                    calculateBtn.onclick = () => {
                        const weight = parseFloat(weightInput.value);
                        const heightCm = parseFloat(heightInput.value);

                        if (isNaN(weight) || isNaN(heightCm) || weight <= 0 || heightCm <= 0) {
                            showAlert('Please enter valid positive numbers for weight and height.', 'error');
                            resultDiv.style.display = 'none';
                            return;
                        }
                        const heightM = heightCm / 100;
                        const bmi = weight / (heightM * heightM);
                        let category = '';
                        let color = 'var(--text-color)';

                        if (bmi < 18.5) { category = 'Underweight'; color = '#3498db'; }
                        else if (bmi < 24.9) { category = 'Normal weight'; color = '#2ecc71'; }
                        else if (bmi < 29.9) { category = 'Overweight'; color = '#f1c40f'; }
                        else if (bmi < 34.9) { category = 'Obesity Class I'; color = '#e67e22'; }
                        else if (bmi < 39.9) { category = 'Obesity Class II'; color = '#e74c3c'; }
                        else { category = 'Obesity Class III (Severe)'; color = '#c0392b'; }

                        resultDiv.innerHTML = `Your BMI: <strong style="font-size:1.5em;">${bmi.toFixed(2)}</strong><br>
                                            Category: <strong style="color:${color};">${category}</strong>`;
                        resultDiv.style.display = 'block';
                        hideAlert();
                    };
                },

                timerStopwatch: (container) => {
                    container.innerHTML = `
                        <div class="tabs">
                            <button class="tab-button active" data-tab="timerTab">Timer</button>
                            <button class="tab-button" data-tab="stopwatchTab">Stopwatch</button>
                        </div>

                        <div id="timerTab" class="tab-content" style="padding-top:1rem;">
                            <h3>Timer</h3>
                            <div style="display:flex; justify-content:space-around; margin-bottom:1rem;">
                                <div><label for="timerHours">Hours:</label><br><input type="number" id="timerHours" min="0" max="99" value="0" style="width:60px;"></div>
                                <div><label for="timerMinutes">Mins:</label><br><input type="number" id="timerMinutes" min="0" max="59" value="5" style="width:60px;"></div>
                                <div><label for="timerSeconds">Secs:</label><br><input type="number" id="timerSeconds" min="0" max="59" value="0" style="width:60px;"></div>
                            </div>
                            <div class="timer-display" id="timerDisplay">00:05:00</div>
                            <div style="text-align:center;">
                                <button id="timerStart">Start</button>
                                <button id="timerPause" disabled>Pause</button>
                                <button id="timerReset">Reset</button>
                            </div>
                        </div>

                        <div id="stopwatchTab" class="tab-content" style="display:none; padding-top:1rem;">
                            <h3>Stopwatch</h3>
                            <div class="stopwatch-display" id="stopwatchDisplay">00:00:00.00</div>
                            <div style="text-align:center; margin-bottom:1rem;">
                                <button id="stopwatchStart">Start</button>
                                <button id="stopwatchStop" disabled>Stop</button>
                                <button id="stopwatchReset" disabled>Reset</button>
                                <button id="stopwatchLap" disabled>Lap</button>
                            </div>
                            <ul id="lapsList" class="laps-list"></ul>
                        </div>
                    `;

                    const tabButtons = container.querySelectorAll('.tab-button');
                    const tabContents = container.querySelectorAll('.tab-content');
                    tabButtons.forEach(button => {
                        button.onclick = () => {
                            tabButtons.forEach(btn => btn.classList.remove('active'));
                            button.classList.add('active');
                            tabContents.forEach(content => content.style.display = 'none');
                            container.querySelector(`#${button.dataset.tab}`).style.display = 'block';
                            if (button.dataset.tab === 'timerTab') resetTimerState(false); else resetStopwatchState(false);
                        };
                    });

                    // Timer Logic
                    const timerHoursInput = container.querySelector('#timerHours');
                    const timerMinutesInput = container.querySelector('#timerMinutes');
                    const timerSecondsInput = container.querySelector('#timerSeconds');
                    const timerDisplay = container.querySelector('#timerDisplay');
                    const timerStartBtn = container.querySelector('#timerStart');
                    const timerPauseBtn = container.querySelector('#timerPause');
                    const timerResetBtn = container.querySelector('#timerReset');
                    let timerInterval;
                    let timerTotalSeconds;
                    let timerIsRunning = false;

                    function updateTimerDisplayDOM() {
                        const h = Math.floor(timerTotalSeconds / 3600);
                        const m = Math.floor((timerTotalSeconds % 3600) / 60);
                        const s = timerTotalSeconds % 60;
                        timerDisplay.textContent = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
                    }
                    
                    function setTimerFromInputs() {
                        const h = parseInt(timerHoursInput.value) || 0;
                        const m = parseInt(timerMinutesInput.value) || 0;
                        const s = parseInt(timerSecondsInput.value) || 0;
                        timerTotalSeconds = (h * 3600) + (m * 60) + s;
                        updateTimerDisplayDOM();
                    }
                    [timerHoursInput, timerMinutesInput, timerSecondsInput].forEach(input => {
                        input.onchange = () => { if (!timerIsRunning) setTimerFromInputs(); };
                        input.onkeyup = () => { if (!timerIsRunning) setTimerFromInputs(); };
                    });

                    timerStartBtn.onclick = () => {
                        if (timerIsRunning) return;
                        if (timerTotalSeconds === undefined || timerTotalSeconds === 0) setTimerFromInputs();

                        if (timerTotalSeconds <= 0) {
                            showAlert('Set a duration greater than 0.', 'error');
                            return;
                        }
                        hideAlert();
                        timerIsRunning = true;
                        timerStartBtn.disabled = true;
                        timerPauseBtn.disabled = false;
                        [timerHoursInput, timerMinutesInput, timerSecondsInput].forEach(inp => inp.disabled = true);

                        timerInterval = setInterval(() => {
                            if (timerTotalSeconds > 0) {
                                timerTotalSeconds--;
                                updateTimerDisplayDOM();
                            } else {
                                clearInterval(timerInterval);
                                timerIsRunning = false;
                                timerDisplay.textContent = "Time's Up!";
                                showAlert("Timer finished!", "success");
                                timerStartBtn.disabled = false;
                                timerPauseBtn.disabled = true;
                                [timerHoursInput, timerMinutesInput, timerSecondsInput].forEach(inp => inp.disabled = false);
                                try { new Audio('https://interactive-examples.mdn.mozilla.net/media/cc0-audio/t-rex-roar.mp3').play(); } catch(e){}
                            }
                        }, 1000);
                    };
                    timerPauseBtn.onclick = () => {
                        clearInterval(timerInterval);
                        timerIsRunning = false;
                        timerStartBtn.disabled = false;
                        timerPauseBtn.disabled = true;
                         [timerHoursInput, timerMinutesInput, timerSecondsInput].forEach(inp => inp.disabled = false);
                    };
                    
                    function resetTimerState(showDefaultTime = true) {
                        clearInterval(timerInterval);
                        timerIsRunning = false;
                        if (showDefaultTime) {
                            timerHoursInput.value = '0';
                            timerMinutesInput.value = '5';
                            timerSecondsInput.value = '0';
                        }
                        setTimerFromInputs();
                        timerStartBtn.disabled = false;
                        timerPauseBtn.disabled = true;
                        [timerHoursInput, timerMinutesInput, timerSecondsInput].forEach(inp => inp.disabled = false);
                        hideAlert();
                        timerDisplay.textContent = "00:05:00";
                        if (showDefaultTime) setTimerFromInputs();
                    }
                    timerResetBtn.onclick = () => resetTimerState(true);
                    

                    // Stopwatch Logic
                    const stopwatchDisplay = container.querySelector('#stopwatchDisplay');
                    const stopwatchStartBtn = container.querySelector('#stopwatchStart');
                    const stopwatchStopBtn = container.querySelector('#stopwatchStop');
                    const stopwatchResetBtn = container.querySelector('#stopwatchReset');
                    const stopwatchLapBtn = container.querySelector('#stopwatchLap');
                    const lapsList = container.querySelector('#lapsList');
                    let stopwatchInterval;
                    let stopwatchStartTime;
                    let stopwatchElapsedTime = 0;
                    let lapNumber = 1;
                    let stopwatchIsRunning = false;

                    function formatStopwatchTime(ms) {
                        const totalSeconds = Math.floor(ms / 1000);
                        const minutes = Math.floor(totalSeconds / 60);
                        const seconds = totalSeconds % 60;
                        const milliseconds = Math.floor((ms % 1000)/10);
                        return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(milliseconds).padStart(2, '0')}`;
                    }

                    stopwatchStartBtn.onclick = () => {
                        if (stopwatchIsRunning) return;
                        stopwatchIsRunning = true;
                        stopwatchStartTime = Date.now() - stopwatchElapsedTime;
                        stopwatchInterval = setInterval(() => {
                            stopwatchElapsedTime = Date.now() - stopwatchStartTime;
                            stopwatchDisplay.textContent = formatStopwatchTime(stopwatchElapsedTime);
                        }, 10);
                        stopwatchStartBtn.disabled = true;
                        stopwatchStopBtn.disabled = false;
                        stopwatchLapBtn.disabled = false;
                        stopwatchResetBtn.disabled = false;
                    };
                    stopwatchStopBtn.onclick = () => {
                        clearInterval(stopwatchInterval);
                        stopwatchIsRunning = false;
                        stopwatchStartBtn.disabled = false;
                        stopwatchStopBtn.disabled = true;
                        stopwatchLapBtn.disabled = stopwatchElapsedTime === 0;
                    };
                    function resetStopwatchState(fromTabSwitch = false) {
                        clearInterval(stopwatchInterval);
                        stopwatchIsRunning = false;
                        stopwatchElapsedTime = 0;
                        lapNumber = 1;
                        stopwatchDisplay.textContent = formatStopwatchTime(0);
                        if (!fromTabSwitch) lapsList.innerHTML = '';
                        stopwatchStartBtn.disabled = false;
                        stopwatchStopBtn.disabled = true;
                        stopwatchLapBtn.disabled = true;
                        stopwatchResetBtn.disabled = true;
                    }
                    stopwatchResetBtn.onclick = () => resetStopwatchState(false);
                    
                    stopwatchLapBtn.onclick = () => {
                        if (stopwatchElapsedTime > 0) {
                            const lapTime = stopwatchElapsedTime;
                            const li = document.createElement('li');
                            li.textContent = `Lap ${lapNumber++}: ${formatStopwatchTime(lapTime)}`;
                            lapsList.prepend(li);
                        }
                    };
                    
                    resetTimerState(true);
                    resetStopwatchState(false);

                    window.currentToolCleanup = () => {
                        clearInterval(timerInterval);
                        clearInterval(stopwatchInterval);
                    };
                }                    
            };

            const defaultTimerTabButton = document.querySelector('.tab-button[data-tab="timerTab"]');
            if (defaultTimerTabButton) defaultTimerTabButton.click();
        });
    </script>
</body>
</html>
